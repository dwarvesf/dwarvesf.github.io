{{- $url := urls.Parse .Destination -}}
{{- $scheme := $url.Scheme -}}

{{ $mozillaPDF := resources.Get "js/pdf-js/pdf.mjs" }}
{{ $mozillaWorkerPDF := resources.Get "js/pdf-js/pdf.worker.mjs" }}
<script src="{{ $mozillaPDF.RelPermalink }}" type="module"></script>

{{- if strings.HasSuffix .Destination ".pdf" -}}
<!-- PDF rendering code remains unchanged -->
{{- else if strings.HasSuffix .Destination ".mp4" -}}
<video
  x-data="{
    title: `{{- with .Title }}{{ . | safeHTML }}{{- end -}}`,
    alt: `{{- with .Text }}{{ . | safeHTML }}{{- end -}}`,
    src: `{{- .Destination | lower }}`,
    altText: `{{- with .Text }}{{ . | safeHTML }}{{- end -}}`,
    get altWidthHeight() {
      const widthHeightRegex = /^(\d+)(?!x)(\d*)$/g;
      return this.altText.match(widthHeightRegex) ?? [];
    },
    get relativeSrc() {
      if (this.src.startsWith('http://') || this.src.startsWith('https://')) {
        return this.src;
      }

      let currentUrlParts = this.currentUrl.split('/');
      currentUrlParts.shift();
      currentUrlParts.pop();
      currentUrlParts.pop();
      const relativeUrl = currentUrlParts.length > 0 ? `/${currentUrlParts.join('/')}/` : '';

      let path = this.src;
      if (path.match(/^assets/)) {
         path = `${relativeUrl}/${path}`;
      } else {
         path = `/${path}`;
      }

      // Split path and slugify each component
      const pathParts = path.split('/').map(part => {
        if (part === '' || part === '.' || part === '..') return part;
        
        // Handle the filename separately to preserve extension
        if (part.includes('.')) {
          const [name, ext] = part.split('.');
          return `${this.slugify(name)}.${ext}`;
        }
        return this.slugify(part);
      });

      return pathParts.join('/').toLowerCase();
    },
    slugify(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s_-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim('-');
    }
  }"
  controls
  :src="relativeSrc"
  :title="title"
  :alt="alt"
  :style="{ width: altWidthHeight[0] + 'px', height: altWidthHeight[1] + 'px' }"
  onerror="this.onerror = null"
></video>
{{- else -}}
<div class="image-container" 
  x-data="{
    title: `{{- with .Title }}{{ . | safeHTML }}{{- end -}}`,
    alt: `{{- with .Text }}{{ . | safeHTML }}{{- end -}}`,
    src: `{{- .Destination | lower }}`,
    altText: `{{- with .Text }}{{ . | safeHTML }}{{- end -}}`,
    isZoomed: false,
    get altWidthHeight() {
      const widthHeightRegex = /^(\d+)(?!x)(\d*)$/g;
      return this.altText.match(widthHeightRegex) ?? [];
    },
    get relativeSrc() {
      if (this.src.startsWith('http://') || this.src.startsWith('https://')) {
        return this.src;
      }

      let currentUrlParts = this.currentUrl.split('/');
      currentUrlParts.shift();
      currentUrlParts.pop();
      currentUrlParts.pop();
      const relativeUrl = currentUrlParts.length > 0 ? `/${currentUrlParts.join('/')}/` : '';

      let path = this.src;
      if (path.match(/^assets/)) {
         path = `${relativeUrl}/${path}`;
      } else {
         path = `/${path}`;
      }

      // Split path and slugify each component
      const pathParts = path.split('/').map(part => {
        if (part === '' || part === '.' || part === '..') return part;
        
        // Handle the filename separately to preserve extension
        if (part.includes('.')) {
          const [name, ext] = part.split('.');
          return `${this.slugify(name)}.${ext}`;
        }
        return this.slugify(part);
      });

      return pathParts.join('/').toLowerCase();
    },
    slugify(text) {
      return text
        .toLowerCase()
        .replace(/[^a-z0-9\s_-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim('-');
    },
    openZoom() {
      this.isZoomed = true;
      document.body.style.overflow = 'hidden';
    },
    closeZoom() {
      this.isZoomed = false;
      document.body.style.overflow = '';
    },
    init() {
      this.$watch('isZoomed', value => {
        if (value) {
          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') this.closeZoom();
          });
        }
      });
    }
  }"
>
  <img 
    :src="relativeSrc"
    :title="title"
    :alt="alt"
    :style="{ width: altWidthHeight[0] + 'px', height: altWidthHeight[1] + 'px' }"
    onerror="this.onerror = null"
    class="content-img"
  />
  <div class="zoom-controls">
    <div class="zoom-in" @click="openZoom()">
      <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <circle cx="11" cy="11" r="8"/>
        <line x1="21" x2="16.65" y1="21" y2="16.65"/>
        <line x1="11" x2="11" y1="8" y2="14"/>
        <line x1="8" x2="14" y1="11" y2="11"/>
      </svg>
    </div>
  </div>

  <!-- Zoom Modal -->
  <div 
    x-show="isZoomed"
    class="zoom-modal"
    @click.self="closeZoom()"
  >
    <div class="zoom-modal-content">
      <img 
        :src="relativeSrc"
        :alt="alt"
        class="zoomed-img"
      />
      <button class="close-zoom" @click="closeZoom()">Ã—</button>
    </div>
  </div>
</div>
{{- end -}}

{{- /* whitespace stripped here to avoid trailing newline in rendered result caused by file EOL */ -}}
