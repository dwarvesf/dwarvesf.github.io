<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Playbooks on Dwarves Foundation</title><link>https://dwarvesf.github.io/playbook/</link><description>Recent content in Playbooks on Dwarves Foundation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><managingEditor>han@d.foundation (Han Ngo)</managingEditor><webMaster>han@d.foundation (Han Ngo)</webMaster><copyright>© 2023 Dwarves Foundation.</copyright><lastBuildDate>Mon, 16 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://dwarvesf.github.io/playbook/index.xml" rel="self" type="application/rss+xml"/><item><title>aarrr</title><link>https://dwarvesf.github.io/playbook/design/aarrr/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/aarrr/</guid><description>AARRR framework We use the AARRR framework to measure and optimize every phase of a product by optimizing it through the insane focus on one metric at a time.
What is AARRR framework? The AARRR framework consists of five phases a customer goes through in order to achieve growth and each phase has its own set of metrics to focus on. AARRR stands for Acquisition, Activation, Retention, Referral, and Revenue.</description></item><item><title>business-playbook-outline</title><link>https://dwarvesf.github.io/playbook/business/business-playbook-outline/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/business-playbook-outline/</guid><description> BUSINESS PLAYBOOK Table of Contents
Introduction Who we are The Team Team chart Team members Portfolio Achievements Vision &amp;amp; mission
Strategy
Operating Process
Diagram Process workflows Sales Partnership process Commission model/tier Payment timeline FAQ</description></item><item><title>collaboration-guideline</title><link>https://dwarvesf.github.io/playbook/business/collaboration-guideline/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/collaboration-guideline/</guid><description>Collaboration Guideline Guidelines for project collaboration between DF and Clients.
Tools Project management &amp;amp; communication: Basecamp (invited as Client) Sprint planning &amp;amp; tracking: Jira/Basecamp Meeting: Google Meet Source control platform: Github/Gitlab (self-hosted) Design: Figma/Sketch Schedule Project kick-off meeting: 1 session Sprint length: 1 week/2 weeks Sprint planning meeting: 1 per sprint Sprint review &amp;amp; retrospective meeting: 1 per sprint Sprint daily standup meetings (can as well be done via communication channel or Basecamp’s check-ins) Project/team feedback meeting (with Account Manager): 1 per week or 1 every 2 weeks Meeting notes for Sprint planning and Sprint retrospective will be sent within 30 minutes after meeting.</description></item><item><title>design-sprint</title><link>https://dwarvesf.github.io/playbook/design/design-sprint/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/design-sprint/</guid><description>Design Sprint What is the design sprint? The sprint is a four-day process for answering critical business questions through design, prototyping and testing ideas with customers. Design sprint mostly applied to the Exploration phase. Friday is usually Education event or Lab projects at Dwarves Design, learning and continuous professional and personal development are in the core of our DNA. No one wants to settle, everyone wants to take the next step forward.</description></item><item><title>df-workflow</title><link>https://dwarvesf.github.io/playbook/business/df-workflow/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/df-workflow/</guid><description>Monday: Sprint Planning End-of-day (EOD) check-in message
Tuesday: EOD check-in message
Wednesday: Sprint review message EOD check-in message
Thursday: EOD check-in message Performance review (Account Manager, Team Lead, Project Owner, every 2 weeks)
Friday: Investment time/Tech Radar Sprint Review Retrospective</description></item><item><title>fbsc</title><link>https://dwarvesf.github.io/playbook/business/fbsc/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/fbsc/</guid><description>Budget We do need to know clients&amp;rsquo; budgets. This is often uncomfortable for them but their budget helps determines what scope is possible. It saves time. If they don&amp;rsquo;t know their budget, we discuss different options.
We talk about breaking product rollout into stages and try to improve the product&amp;rsquo;s chances of success at each stage by:
Focusing on a small subset of features. Designing a valuable user experience. Developing a meaningful relationship with users.</description></item><item><title>how-to-work-with-clients</title><link>https://dwarvesf.github.io/playbook/business/how-to-work-with-clients/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/how-to-work-with-clients/</guid><description>TRAINING COURSE: HOW TO WORK WITH CLIENT What skills that an engineer should have in order to work with client effectively?
Strong technical skills: includes Basics of testing: Unit, Integration, System Software testing and debugging Attention to details
Communication skills: good English skills (both written and verbal) -&amp;gt; require somewhere Intermediate - Upper Intermediate level
Problem solving and logical thinking
Work planning
Teamwork
Project Management
Consistency in delivering work result</description></item><item><title>lean-canvas</title><link>https://dwarvesf.github.io/playbook/design/lean-canvas/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/lean-canvas/</guid><description>Lean Canvas Lean Canvas is an adaptation of Business Model Canvas by Alexander Osterwalder which Ash Maurya created in the Lean Startup spirit (Fast, Concise and Effective startup). Lean Canvas promises an actionable and entrepreneur-focused business plan. It focuses on problems, solutions, key metrics, and competitive advantages.
1. Problem What is the crucial problem faced by the product’s consumers? Capture their central frustration. The best way to describe the problem is in terms of the jobs customers need to do, what they are ultimately trying to achieve and what is the pain or frustration they currently feel.</description></item><item><title>prototype</title><link>https://dwarvesf.github.io/playbook/design/prototype/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/prototype/</guid><description>Low-fidelity prototype: UI Design Research 1. Understand prospect Understanding stakeholder, company, business model, goals and challenges of the product in order to set mindset, define style, color palette, and typography, iconography, illustration, and photography.
2. Define product Style Based on the target user and product’s requirement, we define layout style. Make references from Dribbble, Behance and other showcase sites to catch up with the current design trends.
Color Define primary and secondary based on the logo and branding of the product.</description></item><item><title>service-feedbacks</title><link>https://dwarvesf.github.io/playbook/business/service-feedbacks/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/service-feedbacks/</guid><description>GENERAL QUESTIONS FOR SERVICE FEEDBACKS Engineer performances a. Communication
How did the engineer interact with your team? How was the communication between the engineer and your team? Was our engineer proactive in communicating with you? Did our engineer ask lots of questions? On which aspect our engineer should improve to provide better communication? b. Work ethic, delivery
Have our engineers “coming to work” on time? Have you ever had to wait too long to get a response from our engineer?</description></item><item><title>UI</title><link>https://dwarvesf.github.io/playbook/design/ui/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/ui/</guid><description/></item><item><title>UX</title><link>https://dwarvesf.github.io/playbook/design/ux/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/ux/</guid><description>UX Research Framework 1. Gather Data In the first phase, we focus on gathering as much valuable data as humanly possible. It’s time for open-question asking, non-judgmental listening, and meticulous note-taking.
Stakeholder Interview In order to create successful products as a designer, it’s crucial to discover how the stakeholders think - what is the vision for the product (from each of the stakeholders&amp;rsquo; perspectives), and how can these be amalgamated?</description></item><item><title>wireframe</title><link>https://dwarvesf.github.io/playbook/design/wireframe/</link><pubDate>Mon, 16 Oct 2023 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/wireframe/</guid><description>Wireframe: Workflow Design Created on scraps of paper, a whiteboard, or in a software program, serve to establish relationships between elements in a project such as navigation, imagery, and calls to action. Often, a wireframe has 3 core goals:
To show the content and functionality of the pages before any further designs. To help designers communicate with clients about the design concept. To establish the information hierarchy of the site.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/business/invoice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/invoice/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/business/nda/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/business/nda/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/design/design-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/design-system/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/design/ia/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/ia/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/design/ix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/design/ix/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/12-factor-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/12-factor-app/</guid><description>The 12-factor App The 12-factor apps let us write modern software as a service which is easy to deploy, scale up, maximize portability, and minimize time, the cost for new developers joining the project.
You can read more about the philosophy of the 12-factor app https://12factor.net. Here we only show how we apply those in real projects.
Codebase One codebase tracked in revision control, many deploys
A twelve-factor app is always tracked in a version control system.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/android/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/android/</guid><description>Best practices in Android development Avoid reinventing the wheel by following these guidelines.
Summary Use Gradle and its default project structure Put passwords and sensitive data in gradle.properties Use the Jackson library to parse JSON data Don&amp;rsquo;t write your own HTTP client, use OkHttp libraries Avoid Guava and use only a few libraries due to the 65k method limit Sail carefully when choosing between Activities and Fragments Layout XMLs are code, organize them well Use styles to avoid duplicate attributes in layout XMLs Use multiple style files to avoid a single huge one Keep your colors.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/backend/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/backend/</guid><description>Best practices in backend development N Commandments General points on guidelines Development environment setup in README.md Data persistence General considerations SaaS, cloud-hosted or self-hosted? Persistence solutions RDBMS NoSQL Document storage Key-value store Graph database Bill of Materials Security Docker Credentials Secrets Login Throttling User Password Storage Audit Log Suspicious Action Throttling and/or blocking Anonymized Data Temporary file storage Dedicated vs Shared server environment Checklists Responsibility checklist Release checklist General questions to consider Generally proven useful tools N Commandments README.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/basic-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/basic-security/</guid><description>Basic Security Devices Keeping laptops and phones secure is vitally important. We&amp;rsquo;re a software company and many of us have access to secure systems (both our own and our customers).
The following guidelines apply to how we physically secure our laptops and mobile devices that may contain customer or user data.
General Make a note of serial numbers, model information Two Factor Authentication and strong passwords Keep your operating system and applications up to date Lock your device when you are away from it.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/</guid><description>Best practices in blockchain development N Commandments Encryption knowledge Basic concepts Digital signature extension Merkle tree Blockchain Basics [Learn the basics of Distributed Ledger Technology] Ethereum blockchain Elliptic Curve Cryptography Proof of Work Proof of Stake [Practical Byzantine Fault Tolerance] [Development environment setup in README.md] [Hardhat] [Anchor] [Blockchain data] [General considerations] [Introduction to Distributed Storage] [Persistence solutions] [IPFS] [SWARM] [Learn Solidity] [Solidity Smart contract basic] [Remix IDE] [Smart contract token] [Smart contract NFT] [Deploy and upgrade] [Learn Solana Rust] [Rust basic] [Anchor language] [Deploy and upgrade] [Token program] [Blockchain RPC] [EVM RPC] [Solana RPC] [IPC RPC] [NEAR RPC] [WEB3] [etherJS] [Web3JS] [Provider] [EIP] [General] [Most basics] [Security] [Private key] [Multisign wallet] [Secrets] [Audit checklist] Checklists Responsibility checklist Release checklist General questions to consider Generally proven useful tools N Commandments README.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/assert-require-revert/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/assert-require-revert/</guid><description>Enforce invariants with assert() An assert guard triggers when an assertion fails - such as an invariant property changing. For example, the token to ether issuance ratio, in a token issuance contract, may be fixed. You can verify that this is the case at all times with an assert(). Assert guards should often be combined with other techniques, such as pausing the contract and allowing upgrades. (Otherwise, you may end up stuck, with an assertion that is always failing.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/blockchain-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/blockchain-security/</guid><description>Blockchain Security Checklist Understanding the project CENTRALIZATION / PRIVILEGE Secure the function have access by owner Initial token distribution, should prefix receiver address Use multisign wallet for dev Unrestricted privilege function EVENT LOG Event for any set function Event for significant transactions Event name must clear and avoid misunderstand Favor capitalization and a prefix in front of events (we suggest Log) VOLATILE CODE Avoid Reentrancy Check the return value of external call such as transfer Avoid state change after call external function Math Operation Check insecure arithmetic, integer under/overflow Validity check Clear Code structure Don&amp;rsquo;t use transfer() or send() Handle errors in external call ( can use try/catch) Favor pull over push for external calls Don&amp;rsquo;t delegatecall to untrusted code Force-feeding Ether GAS OPTIMIZATION Don&amp;rsquo;t use recursive function Use appropriate type (uint8, map&amp;hellip;) Initial variable in constructor Use external function instead of public UNIT TEST Unit test for get/set function Unit test for overflow data Unit test for external call Run unit test before deploy CODING STYLE Language specific Store config of upgrade contract and push to git Check Reusable Code, use modifier Check for minimal source code Have note/status for deployed code LOGICAL ISSUE Check over minted token Don&amp;rsquo;t trust tx.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/documents/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/documents/</guid><description>When launching a contract that will have substantial funds or is required to be mission critical, it is important to include proper documentation.
Contact Who to contact with issues Names of programmers and/or other important parties Chat room where questions can be asked History Testing (including usage stats, discovered bugs, length of testing) People who have reviewed code (and their key feedback) Known-issues Key risks with contract e.g., You can lose all your money, hacker can vote for certain outcomes All known bugs/limitations Potential attacks and mitigants Potential conflicts of interest (e.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/external-calls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/external-calls/</guid><description>Use caution when making external calls Calls to untrusted contracts can introduce several unexpected risks or errors. External calls may execute malicious code in that contract or any other contract that it depends upon. As such, every external call should be treated as a potential security risk. When it is not possible, or undesirable to remove external calls, use the recommendations in the rest of this section to minimize the danger.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/general/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/general/</guid><description>1. Abstract-vs-interfaces Be aware of the tradeoffs between abstract contracts and interfaces. Both interfaces and abstract contracts provide one with a customizable and re-usable approach for smart contracts. Interfaces, which were introduced in Solidity 0.4.11, are similar to abstract contracts but cannot have any functions implemented. Interfaces also have limitations such as not being able to access storage or inherit from other interfaces which generally makes abstract contracts more practical.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/precautions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/precautions/</guid><description>As we discussed in the General Philosophy section, it is not enough to protect yourself against the known attacks. Since the cost of failure on a blockchain can be very high, you must also adapt the way you write software, to account for that risk.
The approach we advocate is to &amp;ldquo;prepare for failure&amp;rdquo;. It is impossible to know in advance whether your code is secure. However, you can architect your contracts in a way that allows them to fail gracefully, and with minimal damage.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/blockchain/token/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/blockchain/token/</guid><description>Frontrunning The EIP-20 token&amp;rsquo;s approve() function creates the potential for an approved spender to spend more than the intended amount. A front running attack can be used, enabling an approved spender to call transferFrom() both before and after the call to approve() is processed. More details are available on the EIP, and in this document.
Standardization Generally speaking, smart contracts of tokens should follow an accepted and stable standard.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/changelog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/changelog/</guid><description>Writing a useful changelog Remember the last time you read over the changelog of your favorite app and found it sucks with useless information like they don&amp;rsquo;t care about the product that they sell out. Something like below
2.11.4
Some bugs fixed or
Fix bugs and improve UI/UX They are awkward, and the same thing happens for our end users. As a user, we care about what&amp;rsquo;s news in the software that we use every day.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/charter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/charter/</guid><description>Project Charter Definitions Project Charter is a formal, typically short document that describes your project in its entirety — including what the objectives are, how it will be carried out, and who the stakeholders are. It is a crucial ingredient in planning out the project because it is used throughout the project lifecycle.
Why is the Project Charter So Important? The benefits of Project Charters for the development team. Helps determine project value: help the team determine if it’s worthwhile to carry out or propose the project.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/ci-cd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/ci-cd/</guid><description>Continuous Integration What Continuous Integration (CI) is a development practice where developers integrate code into a shared repository frequently, preferably several times a day. Each integration can then be verified by an automated build and automated tests. While automated testing is not strictly part of CI it is typically implied.
One of the key benefits of integrating regularly is that you can detect errors quickly and locate them more easily.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/code-review/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/code-review/</guid><description>Code Review How we do code review at Dwarves Foundation.
Every project member must have another team member or team leader to review his/her code, and every changes to the code must be achieved via a Pull request to the main development branch. On larger project (10 developers+) we may requires 2 reviewers. All of this is to ensure correctness, quality of the code and learning opportunities for both assignee (who develop) and reviewer.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/db-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/db-migration/</guid><description>Database migration Mobile macOS / iOS:
Use ObjectMapper cua CoreData de migrate: https://williamboles.me/step-by-step-core-data-migration/ Android
https://medium.com/flutter-community/migrating-a-mobile-database-in-flutter-sqlite-44ac618e4897 Backend Su dung migration tool tuy ngon ngu Go: sql-migrate Elixir: ecto Tips / Best practices checklist Luon viet migrate up / down back up before migration data validation &amp;amp; repair Prefer ORM migration tool Do not deploy the code first: Do not deploy the code first that write to new columns, and then run the migration.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/definition-of-done/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/definition-of-done/</guid><description>Definition of done also known as DoD is a list of criteria which must be met before a product increment (story) is considered &amp;ldquo;done&amp;rdquo;.
In software, Done means
coded to standards reviewed implemented with unit test well documented In a services context, Done means
every task under the User Story has been completed and any work created is attached to the User Story so the Product Owner can review it and it meets his or her expectations.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/diagram/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/diagram/</guid><description>Diagram and Project Document Structure We have talked about SDLC before and have learned that with a lot of constraints, the project is easy to fail. We could have plenty of reasons why a software project fails: team politics, overdue payment,&amp;hellip; but three of them could be prevented easily with proper methodology, framework
Unclear/misleading project requirements Wrongly defined tech stacks The wrong approach, develop practices There is one secret sauce of a successful project: Artifacts.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/editor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/editor/</guid><description>Code editors Right now our team is scattered between VSCode and Emacs (Spacemacs).
The VSCode gang enjoy pretty syntax themes, excellent auto-completion for most languages, fast integrated terminal and awesome Git integration.
The Spacemacs gang live far from the human realm, with all 10 fingers moving constantly to ramp through everything they open, writing Elisp to change editor&amp;rsquo;s behavior on-the-fly, switching projects or playing next Spotify song is just a keymap away.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/environment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/environment/</guid><description>Environments This section describes the environments you should have, at a minimum. It might sound like a lot, but there is a purpose for each one.
Local development Continuous integration Testing Staging Production We use docker and docker-compose to set up our environments. Before getting more profound, we suggest you install our dotfiles, where we share the configuration and setting.
Local development environment This is your device, where you write code.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/error/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/error/</guid><description>Error Message Convention We use the following structure for our error message. It helps our system stay consistent, easier to present between components and also better for error tracking.
To make it easy to build informative error messages. To make errors easy to understand for users. To make errors helpful as diagnostics for programmers. Library Go: https://github.com/dwarvesf/gerr Elixir: https://github.com/dwarvesf/error.ex Swift: https://github.com/dwarvesf/error.swift Error Structure - type: list of common or pre-defined error type - message: error message - errors: actual error value in details - trace_id: Type of error We classify the error into some type:</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/frontend/code-style/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/frontend/code-style/</guid><description>Code style While the vast majority of base code style is enforced by ESLint and Prettier, please also where possible, stick to the contribution guidelines below. These rules should be kept in mind when reviewing Pull Requests:
Code should be functional in style rather than Object Orientated or Imperative unless there are no clean alternatives.
Use pure functions where possible to make them testable and modular. Avoid mutating variables and the let keyword.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/frontend/logging-monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/frontend/logging-monitoring/</guid><description>Logging and Monitoring This document provides guidance on some key metrics to track when logging and monitoring a frontend application at Dwarves Foundation.
Errors tracing Frontend applications receive a lot of user interactions and unexpected errors can arise quickly. To help developers catch and resolve these errors easily, we need a tool can:
Integrate to the staging and dev environments in order to catch any new issues before they become production bugs.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/frontend/tech-ecosystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/frontend/tech-ecosystem/</guid><description>Tech ecosystem This document is intended to give you a taste of how we build frontend applications at Dwarves, and more importantly, why we choose the technology. It still assumes basic knowledge of React and Next.js. If you&amp;rsquo;re completely new to React, please refer to https://github.com/petehunt/react-howto instead!
Tech stack Core React Next.js SWR React Hook Form Dwarves React Toolkit UI &amp;amp; styling TailwindCSS Headless UI Static type checking &amp;amp; linting TypeScript ESLint Prettier Testing Jest react-testing-library Cypress Core Building Blocks React When we choose a technology, the first question always is &amp;ldquo;did that technology achieve a certain level of stability and maturity?</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/frontend/ui-checklist/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/frontend/ui-checklist/</guid><description>UI Checklist Frontend engineering is not just about producing high quality code but also attentive design. Whether you work on a design or transform a design to code, make sure the below checklist is done before you ship.
Is relative spacing to UI elements as base unit of 4? Does your relative spacing match the relative spacing of similar UI elements? Does it look good on desktop, tablet, and mobile?</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/frontend/writing-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/frontend/writing-test/</guid><description>Writing test Testing your application is a vital part of serious development. For the front-end, you don&amp;rsquo;t need 100% code coverage, about 70% is probably good enough. Following are some principles:
Write tests. Not too many. Mostly integration. Tests should make you more productive not slow you down. Maintaining tests can slow you down. You get dimishing returns on adding more tests after a certain point. Your tests should always resemble the way your software is used.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/git/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/git/</guid><description>Source Version Control It&amp;rsquo;s like a time machine. We can save and reload anytime we want to, like in the old day of Game Boy Advance. We can work in parallel universes of our source code, experimenting without fear of losing work, and rolling back if something goes wrong.
We use git. Git is one of the most popular distributed source version control. We use Github to open source our works, playbook, and practices.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/handover/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/handover/</guid><description>Handover This is the checklist for our handover process. When a new person joins a project, project members are changed, or project is moved to another team, a handover should be thoroughly planned and executed.
Why? Reduce handover time. Make clear for everyone how handover will affect schedules/communication/budget. Reduce risks of post-handover work. Ensure good confidence for new members. Handover is not a task, and it is not instant. Handover is always a project.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/incident-management/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/incident-management/</guid><description>Incident management is the practice of responding to an unplanned event, user disruption, or service interruption and involves restoring the service to an operational or acceptable state. There are 2 general labels for incidents:
Incident: An unplanned interruption to a service or reduction in the service quality. Major incident: An incident with significant business impact, requiring an immediate coordinated resolution. A problem or issue is a not-yet-known root cause behind one or more incidents.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/ios-db-migration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/ios-db-migration/</guid><description>Database migration in iOS development Database migration is one of the most important aspects of software development in general and of iOS development in specific. If we do not handle it correctly, it would cause some bad user experiences, such as data loss, app crashing, etc. And finally, lead to the bad reputation for the company. So, we MUST handle it correctly. And this post is a lighthouse which lead you to the right path.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/ios/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/ios/</guid><description>Best practices in iOS development Avoid reinventing the wheel by following these guidelines.
Why? Getting on board with iOS can be intimidating. Neither Swift nor Objective-C are widely used elsewhere, the platform has its own names for almost everything, and it&amp;rsquo;s a bumpy road for your code to actually make it onto a physical device. This living document is here to help you, whether you&amp;rsquo;re taking your first steps in Cocoaland or you&amp;rsquo;re curious about doing things &amp;ldquo;the right way&amp;rdquo;.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/license/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/license/</guid><description>Licensing Why license? By definition, license is a permit from an authority to own or use something. In software development, the term expanded to the permission to use the software as well as the source code itself.
Understanding licenses will help you to prevent a lot of painful situation in the future, including lawsuit involvement.
Copyright and Copyleft In general, copyright law is used by an author to prohibit recipients from reproducing, adapting, or distributing copies of their work.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/log/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/log/</guid><description>Logging system Logs are for auditing. There is a well-defined process for accessing and searching through logs. For every project that we worked with, a single server or multiple services, we always bring on our log stack to track what happens in the system.
We store the system log centralized and grant permission for each project member. We divide the log category into System and Business; with different levels for quick access.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/monitoring/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/monitoring/</guid><description>Monitoring Monitoring Application monitoring Status page Status page format Plain format JSON format HTTP status codes Load balancer health checks Access control Application monitoring Monitoring the full status of a service requires that both OS-level and application-specific monitoring checks are performed. OS-level checks include, for example, CPU, disk or memory usage, running processes, open ports, etc. Application specific checks are, however, the most important from the point of view of the running service.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/presentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/presentation/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/production/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/production/</guid><description>Production Checklist Long-running processes such as email should delivery being run in background jobs? Are there redundant (at least two) web and background processes running? Are we using SSL? Never send credentials unencrypted over public network. Always use encryption (such as HTTPS, SSL, etc.). Are API requests being made via a separate subdomain (api.example.com)? Even if the same app, this gives us architectural flexibility in the future. Are we monitoring performance and uptime?</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/qa/defect-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/qa/defect-template/</guid><description>Defect Report template Summary A summary of the bug should be no more than 60 words. A good summary should be able to answer the three following questions:
What? – What has happened with the application? How? – What did we click/do to produce the bug? Where? – Where exactly in the app did we find the bug? What is the webpage and/or server (environment)? Description A clear and concise description should contain following sections:</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/qa/qa-best-practices/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/qa/qa-best-practices/</guid><description>QA best practises This is a summary of best practices our QA engineers at Dwarves use and recommends to be used. It is not supposed to be a detailed description and sometimes cannot fully be used for all tasks but as an overview of the most important QA processes and a list of good practices that should be used.
QA practices Everyone in Dwarves has QA responsibilities, even if there is a named QA manager or QA specialists.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/qa/testing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/qa/testing/</guid><description>Testing Testing materials Test Plan Make sure these items included in your test plan:
The components and functions to be tested. The components and functions NOT to be tested. The risks of the project that might impact the test plan. Resource planning and responsibilities. External testing team (For example: UAT). Communication method. Test Suite/ Test Case Test case should includes those information:
Name Pre-condition Test Steps Expected Result Requirement Ref Brief about TC Pre-condition steps before executing TC Test Case Steps Expected result for the step User Story # or requirement specification Ex: Login successfully with google User is at login page (https://staging.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/qa/uat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/qa/uat/</guid><description>UAT Checklist User Acceptance Testing can be a daunting and frustrating experience. Too often, the exercise becomes an ordeal of tight deadlines, stress, and system issues. While UAT will always be a high-effort activity, good preparation, responsiveness, and follow-up will multiply your chances of success.
Before UAT All features are completed by the development team. All features are fully tested by (internal) QC. All features are fully deployed to staging or UAT environment.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/rdd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/rdd/</guid><description>README Driven Development A perfect implementation of the wrong specification is worthless By the same principle a beautifully crafted library with no documentation is also damn near worthless. If your software solves the wrong problem or nobody can figure out how to use it, there’s something very bad going on.
Write your Readme first.
First. As in, before you write any code or tests or behaviors or stories or ANYTHING.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/readme-how/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/readme-how/</guid><description>README A README is a text file that introduces and explains a project. It contains information that is commonly required to understand what the project is about.
Why we need readme? It&amp;rsquo;s an easy way to answer questions that your audience will likely have regarding how to install and use your project and also how to collaborate with you.
Who write readme? Anyone who is working on a programming project, especially if you want others to use it or contribute.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/readme-template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/readme-template/</guid><description>Project Title One Paragraph of project description goes here
Getting Started These instructions will get you a copy of the project up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a live system.
Prerequisites What things you need to install the software and how to install them
Give examples Installing A step by step series of examples that tell you how to get a development env running</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/release/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/release/</guid><description>Release Checklist When you are ready to release, remember to check off everything on your release checklist. Just remember to not mess up with the end users. Our responsibility is to keep the system stable with seamless deployment.
Do NOT release on Friday or weekend. We can&amp;rsquo;t handle if any issue happens. The milestone was fully implemented. Git
The PRs contained context and information for tracing back. Git commits message was squashed up.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/repo-icon/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/repo-icon/</guid><description/></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/restful/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/restful/</guid><description>RESTful API An API is a user interface for developers. Put the effort in to ensure it&amp;rsquo;s not just functional but pleasant to use.
Terminologies The following are the most important terms related to REST APIs.
Resource is an object or representation of something, which has some associated data with it, and there can be a set of methods to operate on it. E.g., Animals, schools, and employees are resources, and delete, add, update are the operations to be performed on these resources.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/security/api-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/security/api-security/</guid><description>API Security Checklist Authentication Consider not using Basic Auth. Use standard authentication (e.g. JWT, OAuth). Don&amp;rsquo;t reinvent the wheel in Authentication, token generation, password storage. Use the standards. Use Max Retry and jail features in Login. Use encryption on all sensitive data. JWT (JSON Web Token) Use a random complicated key (JWT Secret) to make brute forcing the token very hard. Don&amp;rsquo;t extract the algorithm from the payload. Force the algorithm in the backend (HS256 or RS256).</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/security/dev-security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/security/dev-security/</guid><description>Development Security Checklist TRANSMITING INFORMATION Never send credentials unencrypted over public network. Always use encryption (such as HTTPS, SSL, etc.). Don&amp;rsquo;t accept passwords or session tokens over HTTP. Use HTTPS for all web traffic. Use HTTPS in the beginning; it&amp;rsquo;s harder to introduce later. Use HTTPS redirects for HTTP traffic. Use HSTS headers to enforce HTTPS traffic. Use secure cookies. Avoid protocol-relative URLs. STORING INFORMATION Never store secrets (passwords, keys, etc.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/setup-laptop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/setup-laptop/</guid><description>Dotfiles In UNIX, the files start with a dot “.” are hidden. If you list files in the directory, they don’t show up and keep them safe from the end users. Because of that reason, the developer usually uses it to store configurations of their tools.
Those files are so-called dotfiles. &amp;lsquo;Dotfile&amp;rsquo; become a generalized term for a UNIX configuration file, typically prefixed with a dot (e.g., .vimrc) and found in your home directory.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/setup-project/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/setup-project/</guid><description>Project Setup Following setup helps us maintain stability and increase the transparency among team members.
Agreement We use GDrive for file storage as specified in our Handbook. As the initiator, you will need to create a subfolder with the project name in the Sales &amp;gt; Agreement folder.
NDA, agreements and all kinds of paperwork between parties will be put there. You can ask the Ops or Business team for help if you don&amp;rsquo;t have the access.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/setup-repository/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/setup-repository/</guid><description>Repository setup How we expect projects to be setup at Dwarves Foundation.
What we expect README.md in the root of the repo is the docs Single command run Single command deploy Repeatable and re-creatable builds Build artifacts bundle a &amp;ldquo;Bill of Materials&amp;rdquo; Technical Project setup must be self-contained, no &amp;ldquo;It works on my machine&amp;rdquo; bullshit. If its failed to run the setup script on your coworker&amp;rsquo;s machine, it needs a fix 🔧</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/stack/</guid><description>Technology Stack Our perspective on Technology New technology needs to provide actual value over existing solutions. Software is changing the world every day. Software moves fast. The technology you used yesterday may be deprecated today. New technology has enabled us to create new things.
The world is running by the goodwill of people who try to make it a better place. With the existing set of problems, new solutions will come out along with new technologies.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/user-story/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/user-story/</guid><description>Agile requirement - User Story What is User Story? In the traditional software development method, requirements are noted as a handful of documentations, specifications&amp;hellip;
In Agile, they are User Story is requirement. User Story is:
A convenient format for expressing the desired business value Crafted in a way that makes them understandable to both business people and technical people Used to provide a great placeholder for a conversation Written at various levels of granularity and are easy to refine Often used with the template: As a &amp;lt;role&amp;gt;, I want &amp;lt;feature&amp;gt; so that &amp;lt;reason&amp;gt; Example:</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/versioning/</guid><description>Versioning Larger applications consists of multiple components that reference each other and rely on compatibility of the interfaces of the components.
To achieve the goal of loosely coupled applications, each component should be versioned independently hence allowing developers to detect breaking changes or seamless updates just by looking at the version number.
Semantic Versioning SemVer or Semantic Versioning is a way of versioning software in the format of MAJOR.MINOR.PATCH:</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/workflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/workflow/</guid><description>The workflow we chose to adopt is a team agreement on why we should be a team player and how we should act to benefit as a whole, not just an individual.
tl;dr; We apply agile philosophy. A few notes to take before working on a project.
Agile is an adjective, not a fancy word. An agile team is about the team, not the tool. Get to know the team and their capability before making any assumption.</description></item><item><title/><link>https://dwarvesf.github.io/playbook/engineering/working-together/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><author>han@d.foundation (Han Ngo)</author><guid>https://dwarvesf.github.io/playbook/engineering/working-together/</guid><description>Pair Programming We encourage pair programming between all levels of experience. Nobody is required to pair program for a certain amount of time, but it is a great tool to help solve complex problems quickly and more efficiently with an extra set of eyes.
Code that is written by two people who sit next to each other at the same computer is pair-programmed code. The best way to pair program is to just sit side by side in front of the monitor.</description></item></channel></rss>